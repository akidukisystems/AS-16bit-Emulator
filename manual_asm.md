# 対応命令
## 読み方
### オペランドの記号
+ r8...AH, AL, BH, BL, CH, CL, DH, DLの8bit汎用レジスタ。
+ r16...AX, BX, CX, DX, SI, DI, SP, BPの16bit汎用レジスタ。
+ m8...メモリ内BYTEサイズオペランド。暗示的にDSレジスタがセグメントレジスタとして使用されます
+ m16...メモリ内WORDサイズオペランド。暗示的にDSレジスタがセグメントレジスタとして使用されます
+ r/m8...r8またはm8のBYTEサイズオペランド
+ r/m16...r16またはm16のWORDサイズオペランド
+ sreg...CS, DS, ES, SSのいずれかのセグメントレジスタ
+ imm8...BYTEサイズ即値
+ imm16...WORDサイズ即値

### 読み方

    MOV ←(1)
        
        ↓(2)	↓(3)	↓(4)
        0x10	movb	dest[r/m8,imm8], src[r/m8,imm8]
        0x11	movw	dest[r/m16,sreg,imm16], src[r/m16,sreg,imm16]

        データを転送します。 ←(5)

        変更されるフラグ ←(6)
        (なし)

    (1)...アセンブラ上で識別されるニーモニック
    (2)...命令コード
    (3)...命令コードに対応する論理ニーモニック（無意味）
    (4)...使用可能なオペランドの種類
    (5)...説明
    (6)...命令実行後のフラグレジスタへの影響
        

## MOV
### 構文
+ 0x10...movb dest[r/m8,imm8], src[r/m8,imm8]
+ 0x11...movw dest[r/m16,sreg,imm16], src[r/m16,sreg,imm16]
+ 0x11...movw dest[r/m8,r/m16,sreg,imm16], src[r/m8,r/m16,sreg,imm16] ※1

### 説明
第一オペランドに第二オペランドの値を格納します。
※1	双方のオペランドが[r/m8]の場合を除く

### 変更されるフラグ
(なし)

----
## XCHG
### 構文
+ 0x13...xchg x[r/m16], y[r/m16]

### 説明
第一オペランドと第二オペランドの値を交換します。

### 変更されるフラグ
(なし)

----
## INC
### 構文
+ 0x20...incb x[r/m8]
+ 0x21...incw x[r/m16,sreg]

### 説明
オペランドの値をインクリメントします。

### 変更されるフラグ
OF, SF, ZF, PF...結果に応じてセットされます

----
## DEC
### 構文
+ 0x22...decb x[r/m8]
+ 0x23...decw x[r/m16,sreg]

### 説明
オペランドの値をデクリメントします。

### 変更されるフラグ
OF, SF, ZF, PF...結果に応じてセットされます

----
## ADD
### 構文
+ 0x24...addb dest[r/m8], src[r/m8,imm8]
+ 0x25...addw dest[r/m16,sreg], src[r/m16,sreg,imm16]

### 説明
第一オペランドに第二オペランドを加算し、第一オペランドに格納します。

### 変更されるフラグ
OF, SF, ZF, AF, PF, CF...結果に応じてセットされます

----
## SUB
### 構文
+ 0x26...subb dest[r/m8], src[r/m8,imm8]
+ 0x27...subw dest[r/m16,sreg], src[r/m16,sreg,imm16]

### 説明
第一オペランドに第二オペランドを減算し、第一オペランドに格納します。

### 変更されるフラグ
OF, SF, ZF, AF, PF, CF...結果に応じてセットされます

----
## MUL
### 構文
+ 0x28...mulb x[r/m8]
+ 0x29...mulw x[r/m16]

### 説明
オペランドとAX（オペランドのサイズがBYTEの場合はAL）を乗算し、DX:AX（オペランドのサイズがBYTEの場合はAX）に格納します。

### 変更されるフラグ
(なし)

----
## DIV
### 構文
+ 0x2A...divb x[r/m8]
+ 0x2B...divw x[r/m16]
### 説明
DX:AX（オペランドのサイズがBYTEの場合はAX）をオペランドで除算し、余りをDX（オペランドのサイズがBYTEの場合はAH）、商をAX（オペランドのサイズがBYTEの場合はAL）に格納します。
オペランドが0の場合は#DE ゼロ除算例外を発生させます。

### 変更されるフラグ
(なし)

----
## IN
### 構文
+ 0x49...in x[r16], y[r16,imm16]

### 説明
第二オペランドのアドレスの値を第一オペランドにロードします。
※このエミュレータでは、I/Oポートの動作を擬似的に再現するため、実際には第二オペランドの値に対応する機能を実行し、第一オペランドに結果をロードします。

### 変更されるフラグ
(なし)

----
## OUT
### 構文
+ 0x4B...in x[r16,imm16], y[r16]

### 説明
第一オペランドのアドレスに第二オペランドの値をストアします。
※このエミュレータでは、I/Oポートの動作を擬似的に再現するため、実際には第二オペランドの値を引数に、第一オペランドの値に対応する機能を実行します。

### 変更されるフラグ
(なし)

----
## CMP
### 構文
+ 0x50...cmpb x[r/m8], y[r/m8,imm8]
+ 0x51...cmpw x[r/m16], y[r/m16,imm16]

### 説明
第一オペランドから第二オペランドを減算し、結果に基づいて OF, SF, ZF, AF, PF, CF の各フラグを変更します。
演算結果は破棄されます。

### 変更されるフラグ
OF, SF, ZF, AF, PF, CF...結果に応じてセットされます

----
## PUSH
### 構文
+ 0x60...push x[r/m16,imm16]

### 説明
スタックポインタから2を減算し、スタックポインタが指すアドレスに第一オペランドをストアします。

### 変更されるフラグ
(なし)

----
## POP
### 構文
+ 0x61...pop x[r/m16,imm16]

### 説明
スタックポインタが指すアドレスから第一オペランドにロードし、スタックポインタを2加算します。

### 変更されるフラグ
(なし)

----
## PUSH
### 構文
+ 0x62...pusha

### 説明
AX, BX, CX, DX, BP, SP, DI, SIをすべてスタックにプッシュします。
順番は AX, CX, DX, BX, SP, BP, SI, DI の順番です。結果的にスタックポインタは8減算されます。

### 変更されるフラグ
(なし)

----
## POPA
### 構文
+ 0x63...popa

### 説明
AX, BX, CX, DX, BP, SP, DI, SIにすべてスタックからポップします。
順番は DI, SI, BP, SP, BX, DX, CX, AX の順番です。結果的にスタックポインタは8加算されます。

### 変更されるフラグ
(なし)

----
## PUSHF
### 構文
+ 0x64...pushf

### 説明
フラグレジスタをスタックにプッシュします。結果的にスタックポインタは2減算されます。

### 変更されるフラグ
(なし)

----
## POPF
### 構文
+ 0x65...popf

### 説明
フラグレジスタにスタックからポップします。結果的にスタックポインタは2加算されます。

### 変更されるフラグ
ポップされた値がフラグレジスタの内容になります。

----
## HLT
### 構文
+ 0x70...hlt

### 説明
プロセッサを停止します。割り込みがあるか、リブートが要求される（emu_vbin_needReboot が 1 になる）まで停止します。

### 変更されるフラグ
(なし)

----
## INT
### 構文
+ 0x71...int x[imm16]

### 説明
ソフトウェア割込みを発生させます。第一オペランドの値と対応する割り込みベクタテーブルの内容を探し、フラグレジスタ、コードセグメント、インストラクションポインタをスタックにプッシュして、指定されたアドレスにジャンプします。結果的にスタックポインタは6減少します。

### 変更されるフラグ
(なし)

----
## INT3
### 構文
+ 0x72...int3

### 説明
ソフトウェア割込みで、デバッグ例外ハンドラを呼び出します。ブレークポイントとして利用できます。

### 変更されるフラグ
(なし)

----
## INTO
### 構文
+ 0x73...into

### 説明
ソフトウェア割込みで、オーバーフローフラグがセットされている場合、#OF オーバーフロー例外（割込み番号4）を呼び出します。

### 変更されるフラグ
(なし)

----
## CALL
### 構文
+ 0x7A...call addr[r/m16, imm16]

### 説明
現在のインストラクションポインタをスタックにプッシュし、第一オペランドのアドレスをインストラクションポインタに設定します。コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## RET
### 構文
+ 0x7B...ret

### 説明
スタックからインストラクションポインタに内容をポップします。コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## CALLF
### 構文
+ 0x7C...callf addr[r/m16, imm16]

### 説明
現在のコードセグメント、インストラクションポインタをスタックにプッシュし、コードセグメントを第一オペランドに、インストラクションポインタを0に設定します。
コードセグメント、インストラクションポインタの順にプッシュします。

### 変更されるフラグ
（なし）

----
## FRET
### 構文
+ 0x7D...fret

### 説明
スタックからインストラクションポインタ、コードセグメントに内容をポップします。
インストラクションポインタ、コードセグメントの順にポップします。

### 変更されるフラグ
（なし）

----
## IRET
### 構文
+ 0x7E...iret

### 説明
スタックからインストラクションポインタ、コードセグメント、フラグレジスタに内容をポップします。
インストラクションポインタ、コードセグメント、フラグレジスタの順にポップします。

### 変更されるフラグ
スタック内容に基づいて変更されます

----
## CCS（非推奨命令）（独自命令）
### 構文
+ 0x7F...ccs

### 説明
インストラクションポインタを、インストラクションポインタ + コードセグメント *0x10 した値に変更し、コードセグメントを0にします。

### 変更されるフラグ
（なし）

----
## Jcc
### 構文
+ 0x9X
	+ 0x90...jo   addr[r/m16, imm16]
	+ 0x91...jno  addr[r/m16, imm16]
	+ 0x92...jb   addr[r/m16, imm16]
	+ 0x93...jnb  addr[r/m16, imm16]
	+ 0x94...je   addr[r/m16, imm16]
	+ 0x95...jne  addr[r/m16, imm16]
	+ 0x96...jbe  addr[r/m16, imm16]
	+ 0x97...jnbe addr[r/m16, imm16]
	+ 0x98...js   addr[r/m16, imm16]
	+ 0x99...jns  addr[r/m16, imm16]
	+ 0x9A...jp   addr[r/m16, imm16]
	+ 0x9B...jnp  addr[r/m16, imm16]
	+ 0x9C...jl   addr[r/m16, imm16]
	+ 0x9D...jnl  addr[r/m16, imm16]
	+ 0x9E...jle  addr[r/m16, imm16]
	+ 0x9F...jnle addr[r/m16, imm16]

### 説明
各フラグをテストし、条件が一致する場合は、インストラクションポインタを第一オペランドに変更します。
コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## JC
### 構文
+ 0xA0...jc addr[r/16, imm16]

### 説明
キャリーフラグをテストし、セットされている場合は、インストラクションポインタを第一オペランドに変更します。
コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## JNC
### 構文
+ 0xA1...jnc addr[r/16, imm16]

### 説明
キャリーフラグをテストし、セットされていない場合は、インストラクションポインタを第一オペランドに変更します。
コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## JCXZ
### 構文
+ 0xA2...jcxz addr[r/16, imm16]

### 説明
CX レジスタが0の場合のみ、インストラクションポインタを第一オペランドに変更します。
コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## JF（独自命令）
### 構文
+ 0xAE...jf addr[r/m16, imm16]

### 説明
セグメントレジスタ ES をコードセグメントに、第一オペランドをインストラクションポインタに変更します。

### 変更されるフラグ
（なし）

----
## JMP
### 構文
+ 0xAF...jmp addr[r/m16, imm16]

### 説明
インストラクションポインタを第一オペランドの内容に変更します。コードセグメントは変更されません。

### 変更されるフラグ
（なし）

----
## DBG（独自命令）
### 構文
+ 0xFD...dbg

### 説明
現在の全てのレジスタの内容、起動からの経過時間とCPUサイクル数をデバッグログに出力します。エミュレータのデバッグ画面に内容が表示されます。

### 変更されるフラグ
（なし）